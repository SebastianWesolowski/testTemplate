import '../fs/index.mjs';
import path$1 from 'path';
import { c as copy$1 } from '../copy/index.mjs';
import { r as remove_1 } from '../remove/index.mjs';
import { m as mkdirs } from '../mkdirs/index.mjs';
import { p as pathExists_1 } from '../path-exists/index.mjs';
import { s as stat$1 } from '../util/stat.mjs';
import { __exports as fs$1 } from '../../../../_virtual/index.mjs';

const fs = fs$1;
const path = path$1;
const { copy } = copy$1;
const { remove } = remove_1;
const { mkdirp } = mkdirs;
const { pathExists } = pathExists_1;
const stat = stat$1;

async function move (src, dest, opts = {}) {
  const overwrite = opts.overwrite || opts.clobber || false;

  const { srcStat, isChangingCase = false } = await stat.checkPaths(src, dest, 'move', opts);

  await stat.checkParentPaths(src, srcStat, dest, 'move');

  // If the parent of dest is not root, make sure it exists before proceeding
  const destParent = path.dirname(dest);
  const parsedParentPath = path.parse(destParent);
  if (parsedParentPath.root !== destParent) {
    await mkdirp(destParent);
  }

  return doRename(src, dest, overwrite, isChangingCase)
}

async function doRename (src, dest, overwrite, isChangingCase) {
  if (!isChangingCase) {
    if (overwrite) {
      await remove(dest);
    } else if (await pathExists(dest)) {
      throw new Error('dest already exists.')
    }
  }

  try {
    // Try w/ rename first, and try copy + remove if EXDEV
    await fs.rename(src, dest);
  } catch (err) {
    if (err.code !== 'EXDEV') {
      throw err
    }
    await moveAcrossDevice(src, dest, overwrite);
  }
}

async function moveAcrossDevice (src, dest, overwrite) {
  const opts = {
    overwrite,
    errorOnExist: true,
    preserveTimestamps: true
  };

  await copy(src, dest, opts);
  return remove(src)
}

var move_1 = move;

export { move_1 as m };
